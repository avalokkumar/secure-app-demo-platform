/**
 * Vulnerability Scanner Service
 * 
 * Provides methods for analyzing code samples for security vulnerabilities.
 * The service includes both real API calls and mock data for development.
 */

import axios from 'axios';
import { mockDelay, isBackendAvailable } from './mockData';

// Create axios instance for API requests
const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:5001/api';

// Create axios instance with authorization header
const apiClient = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json'
  }
});

// Add authorization header to requests when token is available
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('accessToken');
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Mock data for vulnerability analysis
const mockVulnerabilities = {
  "sql-injection": {
    patterns: [
      { regex: /string\s+sql\s*=.*\+.*['"]\s*\+/i, name: "SQL String Concatenation", severity: "high" },
      { regex: /execute(?:Query|Update|Scalar)\s*\([^,)]*\+/i, name: "SQL Injection in Execute", severity: "high" },
      { regex: /SELECT\s+.*\s+FROM\s+.*\s+WHERE\s+.*=\s*['"].*['"].*\+/i, name: "SQL Injection in SELECT", severity: "high" },
    ],
    description: "SQL injection occurs when untrusted data is sent to an SQL interpreter as part of a command or query, allowing an attacker to manipulate queries and access, modify, or delete data.",
    remediation: "Use parameterized queries or prepared statements. Never concatenate user input directly into SQL queries."
  },
  "xss": {
    patterns: [
      { regex: /innerHTML\s*=\s*.*\+/i, name: "DOM XSS via innerHTML", severity: "high" },
      { regex: /document\.write\s*\([^)]*\+/i, name: "DOM XSS via document.write", severity: "high" },
      { regex: /eval\s*\([^)]*\+/i, name: "DOM XSS via eval", severity: "high" },
    ],
    description: "Cross-Site Scripting allows attackers to inject client-side scripts into web pages viewed by other users, bypassing same-origin policy and potentially stealing sensitive data.",
    remediation: "Use context-specific output encoding, Content Security Policy (CSP), and avoid rendering untrusted data in script contexts."
  },
  "csrf": {
    patterns: [
      { regex: /form\s+[^>]*method\s*=\s*["']post["'][^>]*>/i, name: "Form without CSRF token", severity: "medium" },
      { regex: /\$\.(?:post|ajax|get)\s*\(/i, name: "AJAX request without CSRF token", severity: "medium" },
    ],
    description: "Cross-Site Request Forgery tricks users into submitting unwanted requests to a website where they're authenticated, allowing attackers to perform actions with the user's privileges.",
    remediation: "Implement anti-CSRF tokens in forms and AJAX requests, use SameSite cookies, and verify the origin of requests."
  },
  "command-injection": {
    patterns: [
      { regex: /(?:exec|spawn|fork|system|child_process)\s*\([^)]*\+/i, name: "Command Injection", severity: "critical" },
      { regex: /(?:Runtime\.exec|ProcessBuilder)\s*\([^)]*\+/i, name: "Java Command Injection", severity: "critical" },
    ],
    description: "Command injection vulnerabilities allow attackers to execute arbitrary system commands on the host operating system through a vulnerable application.",
    remediation: "Avoid using shell commands with user input. If necessary, use safe APIs and implement proper input validation and parameterization."
  },
  "path-traversal": {
    patterns: [
      { regex: /(?:fs|File)\s*\.\s*(?:read|write)(?:File|Sync)\s*\([^)]*\+/i, name: "Path Traversal", severity: "high" },
      { regex: /\.\.\/|\.\.\\/i, name: "Directory Traversal Sequence", severity: "medium" },
    ],
    description: "Path traversal allows attackers to access files and directories outside of the intended directory by manipulating file paths, potentially exposing sensitive system files.",
    remediation: "Use path canonicalization, validate and sanitize user input, implement proper access controls, and avoid using user input in file operations."
  }
};

/**
 * Analyzes a code sample for known security vulnerabilities
 * 
 * @param {string} code - The code to analyze
 * @param {string} language - The programming language of the code (e.g., 'javascript', 'python', 'java')
 * @returns {Promise} - Analysis results with identified vulnerabilities
 */
const analyzeCode = async (code, language) => {
  try {
    // Check if backend is available
    if (await isBackendAvailable()) {
      const response = await apiClient.post('/vulnerability/analyze', { code, language });
      return response.data;
    } else {
      // Use mock implementation when backend is not available
      await mockDelay();
      
      return mockAnalyzeCode(code, language);
    }
  } catch (error) {
    console.error('Error analyzing code for vulnerabilities:', error);
    throw error;
  }
};

/**
 * Mock implementation of code analysis for development/demo purposes
 */
const mockAnalyzeCode = (code, language) => {
  const findings = [];
  const vulnerabilityTypes = Object.keys(mockVulnerabilities);
  
  // Analyze code against each vulnerability pattern
  vulnerabilityTypes.forEach(vulnType => {
    const vulnerability = mockVulnerabilities[vulnType];
    
    vulnerability.patterns.forEach(pattern => {
      const regex = pattern.regex;
      if (regex.test(code)) {
        // Find line numbers where the vulnerability appears
        const lines = code.split('\n');
        const vulnerableLines = [];
        
        lines.forEach((line, index) => {
          if (regex.test(line)) {
            vulnerableLines.push(index + 1);
          }
        });
        
        findings.push({
          type: vulnType,
          name: pattern.name,
          severity: pattern.severity,
          lines: vulnerableLines,
          description: vulnerability.description,
          remediation: vulnerability.remediation
        });
      }
    });
  });
  
  return {
    findings,
    summary: {
      total: findings.length,
      critical: findings.filter(f => f.severity === 'critical').length,
      high: findings.filter(f => f.severity === 'high').length,
      medium: findings.filter(f => f.severity === 'medium').length,
      low: findings.filter(f => f.severity === 'low').length
    }
  };
};

/**
 * Gets reference information about a specific vulnerability type
 * 
 * @param {string} vulnerabilityType - Type of vulnerability to get reference for
 * @returns {Promise} - Reference information for the specified vulnerability
 */
const getVulnerabilityReference = async (vulnerabilityType) => {
  try {
    // Check if backend is available
    if (await isBackendAvailable()) {
      const response = await apiClient.get(`/vulnerability/reference/${vulnerabilityType}`);
      return response.data;
    } else {
      // Use mock implementation when backend is not available
      await mockDelay();
      
      return mockVulnerabilities[vulnerabilityType] || {
        description: "No reference information available.",
        remediation: "Refer to OWASP for secure coding practices."
      };
    }
  } catch (error) {
    console.error('Error getting vulnerability reference:', error);
    throw error;
  }
};

const VulnerabilityService = {
  analyzeCode,
  getVulnerabilityReference
};

export default VulnerabilityService;
