-- SQL script to add lessons to intermediate and advanced modules
-- This inserts lessons directly into the database
-- Compatible with MariaDB/MySQL

USE sadp;

-- Module IDs (from backend scripts)
-- These IDs must match the ones used in the backend Python scripts
SET @CSRF_MODULE_ID = '70962424-4ed9-11f0-8cc9-26298fe937f6';
SET @ACCESS_CONTROL_MODULE_ID = '70962c4e-4ed9-11f0-8cc9-26298fe937f6';
SET @BUFFER_OVERFLOW_MODULE_ID = '70962dd4-4ed9-11f0-8cc9-26298fe937f6';
SET @RCE_MODULE_ID = '70962e2e-4ed9-11f0-8cc9-26298fe937f6';

-- Helper function to generate UUID v4 (for MariaDB/MySQL compatibility)
DELIMITER //
DROP FUNCTION IF EXISTS uuid_generate_v4//
CREATE FUNCTION uuid_generate_v4() RETURNS CHAR(36) DETERMINISTIC
BEGIN
    DECLARE b BINARY(16);
    SET b = RANDOM_BYTES(16);

    -- Set version to 4 => xxxx4xxx
    SET b = INSERT(b, 7, 1, CHAR(ASCII(SUBSTRING(b, 7, 1)) & 0x0f | 0x40));
    -- Set variant to 8, 9, A, or B => yxxx
    SET b = INSERT(b, 9, 1, CHAR(ASCII(SUBSTRING(b, 9, 1)) & 0x3f | 0x80));

    RETURN LOWER(CONCAT_WS('-',
        HEX(SUBSTRING(b, 1, 4)),
        HEX(SUBSTRING(b, 5, 2)),
        HEX(SUBSTRING(b, 7, 2)),
        HEX(SUBSTRING(b, 9, 2)),
        HEX(SUBSTRING(b, 11, 6))
    ));
END//
DELIMITER ;

-- Begin transaction for all inserts
START TRANSACTION;

-- CSRF Module Lessons
INSERT INTO lessons (id, module_id, title, slug, description, content_type, content, order_index, is_active, created_at, updated_at)
VALUES 
(uuid_generate_v4(), @CSRF_MODULE_ID, 'Understanding CSRF Attacks', 'understanding-csrf-attacks', 
'Learn the fundamentals of Cross-Site Request Forgery attacks and how they exploit user trust.', 
'markdown', 
'# Understanding CSRF Attacks

## Introduction to CSRF

Cross-Site Request Forgery (CSRF) is a type of web security vulnerability that allows an attacker to trick authenticated users into performing unwanted actions on a web application. Unlike XSS, which exploits the trust a user has for a site, CSRF exploits the trust that a website has in a user''s browser.

## How CSRF Works

CSRF attacks work by taking advantage of websites that rely solely on session cookies for authentication. Here''s a typical scenario:

1. You log into your bank account at bank.com and receive an authentication cookie.
2. Without logging out, you visit a malicious website.
3. The malicious site contains code that automatically sends a request to bank.com to transfer money.
4. Since your browser still has the authentication cookie for bank.com, the request is sent with your credentials.
5. The bank processes the transaction because it appears to be coming from you.

## Common CSRF Attack Vectors

- **GET Requests**: Simple image tags or iframes that execute when loaded.
- **POST Requests**: Hidden forms that automatically submit using JavaScript.
- **Clickjacking**: Tricking users into clicking on disguised buttons that trigger actions.', 
0, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),

(uuid_generate_v4(), @CSRF_MODULE_ID, 'CSRF Protection Mechanisms', 'csrf-protection-mechanisms', 
'Learn about various techniques to protect web applications from CSRF attacks.', 
'markdown', 
'# CSRF Protection Mechanisms

## Anti-CSRF Tokens

The most common and effective protection against CSRF attacks is the use of anti-CSRF tokens (also called synchronizer tokens or challenge tokens). These are unique, unpredictable values that are generated by the server and sent to the client.

### How Anti-CSRF Tokens Work

1. The server generates a unique token and includes it in the form.
2. When the form is submitted, the token is sent back to the server.
3. The server verifies that the token is valid before processing the request.
4. Attackers cannot guess or obtain this token, so they cannot forge valid requests.

## Same-Site Cookies

Modern browsers support the SameSite attribute for cookies, which provides protection against CSRF attacks:

\`\`\`
Set-Cookie: sessionid=abc123; SameSite=Strict
\`\`\`

SameSite settings:
- **Strict**: The cookie is only sent to the same site as the one that originated it.
- **Lax**: The cookie is sent when the user navigates to the site from another site.
- **None**: The cookie is sent with all requests, but requires the Secure attribute.', 
1, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),

(uuid_generate_v4(), @CSRF_MODULE_ID, 'Implementing CSRF Protection', 'implementing-csrf-protection', 
'Learn how to implement practical CSRF protection in web applications.', 
'markdown', 
'# Implementing CSRF Protection

In this lesson, we''ll implement CSRF protection in a sample web application. We''ll demonstrate how to properly protect against CSRF attacks in different frameworks and scenarios.

## Implementing Anti-CSRF Tokens

### Server-Side Implementation (Node.js/Express)

\`\`\`
const express = require(\'express\');
const session = require(\'express-session\');
const csrf = require(\'csurf\');
const bodyParser = require(\'body-parser\');

const app = express();

/* Set up session middleware */
app.use(session({
  secret: \'your-secret-key\',
  resave: false,
  saveUninitialized: true,
  cookie: {
    secure: process.env.NODE_ENV === ''production'', /* Use secure cookies in production */
    httpOnly: true /* Cookie not accessible via JavaScript */
  }
}));

/* Parse form data */
app.use(bodyParser.urlencoded({ extended: false }));

/* Set up CSRF protection */
const csrfProtection = csrf({ cookie: false }); /* Using session instead of cookie */

/* Apply CSRF protection to all POST routes */
app.post('/api/*', csrfProtection, (req, res, next) => {
  next();
});
\`\`\`

### Client-Side Implementation (HTML Form)

\`\`\`
<form action="/submit-form" method="POST">
  <!-- Hidden field for CSRF token -->
  <input type="hidden" name="_csrf" value="{{csrfToken}}">
  
  <label for="username">Username:</label>
  <input type="text" id="username" name="username">
</form>
\`\`\`', 
2, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),

(uuid_generate_v4(), @CSRF_MODULE_ID, 'CSRF Testing and Case Studies', 'csrf-testing-case-studies', 
'Learn how to test for CSRF vulnerabilities and analyze real-world CSRF attack examples.', 
'markdown', 
'# CSRF Testing and Case Studies

## Testing for CSRF Vulnerabilities

### Manual Testing Approach

1. **Identify Sensitive Actions**: Find actions that change state (e.g., transfers, password changes).

2. **Check for CSRF Protections**: Examine requests for:
   - CSRF tokens in forms or headers
   - SameSite cookie attributes
   - Origin/Referer header validation

3. **Create a Proof of Concept**: Build an HTML file that reproduces the request.

4. **Verify the Attack**: Load the PoC in a browser with an active session to the vulnerable application.

## Real-World CSRF Case Studies

### Case Study 1: Twitter CSRF Vulnerability (2010)

In 2010, Twitter had a CSRF vulnerability that allowed attackers to force users to follow arbitrary accounts:

**Vulnerability**: Twitter''s follow action didn''t require a CSRF token.

**Attack Vector**: A simple link or hidden iframe could trigger the follow action.

**Impact**: Widespread accounts followed malicious profiles without consent.

**Resolution**: Twitter implemented proper CSRF protections and temporarily reset all followers/following relationships.', 
3, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP);

-- Broken Access Control Module Lessons
INSERT INTO lessons (id, module_id, title, slug, description, content_type, content, order_index, is_active, created_at, updated_at)
VALUES 
(uuid_generate_v4(), @ACCESS_CONTROL_MODULE_ID, 'Understanding Access Control', 'understanding-access-control', 
'Learn the fundamentals of access control and its importance in web security.', 
'markdown', 
'# Understanding Access Control

## Introduction to Access Control

Access control is a security technique that regulates who or what can view or use resources in a computing environment. It is a fundamental security concept that minimizes risk to the business or organization.

## Types of Access Control

### Discretionary Access Control (DAC)
In DAC, the owner of a resource determines who can access it. For example, file permissions in operating systems.

### Mandatory Access Control (MAC)
MAC enforces access control based on regulations mandated by a central authority. Users cannot override these rules.

### Role-Based Access Control (RBAC)
RBAC assigns permissions to specific roles, and users are assigned to those roles. Most common in enterprise applications.

### Attribute-Based Access Control (ABAC)
ABAC uses attributes (user attributes, resource attributes, environment attributes) to determine access rights.', 
0, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),

(uuid_generate_v4(), @ACCESS_CONTROL_MODULE_ID, 'Broken Access Control Vulnerabilities', 'broken-access-control-vulnerabilities', 
'Learn about common access control vulnerabilities and how they can be exploited.', 
'markdown', 
'# Broken Access Control Vulnerabilities

## Common Vulnerabilities

### 1. Insecure Direct Object References (IDOR)
IDOR occurs when an application provides direct access to objects based on user-supplied input.

### 2. Missing Function Level Access Control
When authorization checks are performed at the UI level but not at the API or controller level.

### 3. CORS Misconfiguration
Improper Cross-Origin Resource Sharing (CORS) configuration allowing unauthorized domains to access sensitive data.

### 4. Elevation of Privilege
When a user can change their permission level or access resources beyond their authorization.', 
1, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),

(uuid_generate_v4(), @ACCESS_CONTROL_MODULE_ID, 'Implementing Proper Access Controls', 'implementing-proper-access-controls', 
'Learn best practices for implementing access controls in web applications.', 
'markdown', 
'# Implementing Proper Access Controls

## Core Principles

1. **Deny by Default**: Start with denying all access, then explicitly grant permissions as needed.
2. **Least Privilege**: Provide only the minimum necessary access rights.
3. **Complete Mediation**: Verify authorization on every request to a protected resource.
4. **Defense in Depth**: Implement multiple layers of access controls.

## RBAC Implementation Example

\`\`\`
/* Flask example with role-based access control */
from functools import wraps
from flask import Flask, request, abort, g

app = Flask(__name__)

def role_required(role):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not g.user:
                abort(401)  /* Unauthorized */
            if role not in g.user.roles:
                abort(403)  /* Forbidden */
            return f(*args, **kwargs)
        return decorated_function
    return decorator

@app.route("/admin/dashboard")
@role_required("admin")
def admin_dashboard():
    return "Admin Dashboard"

@app.route("/user/profile")
@role_required("user")
def user_profile():
    return "User Profile"
\`\`\`', 
2, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),

-- Buffer Overflow Module Lessons
INSERT INTO lessons (id, module_id, title, slug, description, content_type, content, order_index, is_active, created_at, updated_at)
VALUES 
(uuid_generate_v4(), @BUFFER_OVERFLOW_MODULE_ID, 'Buffer Overflow Fundamentals', 'buffer-overflow-fundamentals', 
'Learn the basics of buffer overflow vulnerabilities and how they work.', 
'markdown', 
'# Buffer Overflow Fundamentals

## What is a Buffer Overflow?

A buffer overflow occurs when a program writes data beyond the boundaries of pre-allocated fixed-length buffers. This can lead to behavior including memory access errors, incorrect results, program crashes, or a breach of system security.

## How Buffer Overflows Work

In low-level languages like C and C++, developers must manually manage memory by allocating and freeing it. When more data is written to a buffer than it can hold, the excess data can overflow into adjacent memory locations.

### Example in C

\`\`\`
#include <string.h>

void vulnerable_function(char *input) {
    char buffer[10]; /* Only 10 bytes allocated */
    strcpy(buffer, input); /* No bounds checking */
}

int main(int argc, char *argv[]) {
    vulnerable_function(argv[1]); /* User-controlled input */
    return 0;
}
\`\`\`

If a user inputs more than 10 characters, the buffer will overflow, potentially overwriting adjacent memory locations.', 
0, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),

(uuid_generate_v4(), @BUFFER_OVERFLOW_MODULE_ID, 'Stack-Based Buffer Overflows', 'stack-based-buffer-overflows', 
'Learn about stack-based buffer overflows and their exploitation techniques.', 
'markdown', 
'# Stack-Based Buffer Overflows

## The Stack and Its Structure

The stack is a region of memory that stores local variables, function parameters, and return addresses. It operates on a Last-In-First-Out (LIFO) principle.

## Stack Buffer Overflow

In a stack buffer overflow, the attacker overwrites local variables and can potentially modify the function''s return address, redirecting the program execution to malicious code.

## Components of a Stack Frame

1. **Local Variables**: Where the vulnerable buffer is typically located
2. **Saved Frame Pointer (SFP)**: Points to the previous stack frame
3. **Return Address**: Where program execution should return after the function completes
4. **Function Parameters**: Arguments passed to the function

## Basic Exploitation Technique

1. Identify a buffer overflow vulnerability
2. Determine the offset to the return address
3. Overwrite the return address with the address of malicious code
4. Include shellcode in the payload', 
1, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),

(uuid_generate_v4(), @BUFFER_OVERFLOW_MODULE_ID, 'Buffer Overflow Mitigation Techniques', 'buffer-overflow-mitigation', 
'Learn about methods to prevent buffer overflow vulnerabilities in code.', 
'markdown', 
'# Buffer Overflow Mitigation Techniques

## Secure Coding Practices

### 1. Use Bounds-Checking Functions

Replace unsafe functions with safer alternatives:

| Unsafe Function | Safer Alternative |
|----------------|------------------|
| `strcpy()`     | `strncpy()`, `strlcpy()` |
| `strcat()`     | `strncat()`, `strlcat()` |
| `gets()`       | `fgets()` |
| `sprintf()`    | `snprintf()` |

### 2. Input Validation

Always validate and sanitize user input, especially length and content.

\`\`\`
/* Example of input validation */
if (strlen(user_input) >= sizeof(buffer)) {
    /* Handle error - input too large */
    return ERROR_INVALID_INPUT;
}
\`\`\`

## System-Level Protections

### 1. Address Space Layout Randomization (ASLR)

ASLR randomizes the memory addresses used by system and application processes, making it harder for attackers to predict memory addresses.

### 2. Data Execution Prevention (DEP) / No-eXecute (NX)

DEP marks memory regions as non-executable, preventing code execution from data pages.

### 3. Stack Canaries

Special values placed between buffers and control data to detect buffer overflows:

\`\`\`
void function() {
    /* Compiler inserts canary */
    char buffer[64];
    /* Code that uses buffer */
    /* Compiler checks if canary is intact before returning */
}
\`\`\`

If the canary is modified, the program terminates.', 
2, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),

-- Remote Code Execution Module Lessons
INSERT INTO lessons (id, module_id, title, slug, description, content_type, content, order_index, is_active, created_at, updated_at)
VALUES 
(uuid_generate_v4(), @RCE_MODULE_ID, 'Introduction to Remote Code Execution', 'introduction-to-rce', 
'Learn the basics of Remote Code Execution (RCE) vulnerabilities and their impact.', 
'markdown', 
'# Introduction to Remote Code Execution

## What is Remote Code Execution (RCE)?

Remote Code Execution is a critical vulnerability that allows an attacker to execute arbitrary code on a target system remotely. RCE vulnerabilities give attackers the ability to compromise a system completely, potentially leading to data theft, system damage, or use of the compromised system to attack other targets.

## Common RCE Vulnerability Types

### 1. Command Injection
When user input is improperly sanitized and used directly in system commands.

### 2. Deserialization Vulnerabilities
When untrusted data is deserialized, potentially leading to code execution if the serialized data contains malicious code.

### 3. Server-Side Template Injection
When user input is incorporated into templates that are then executed on the server.

### 4. File Upload Vulnerabilities
When file upload functions allow executable code to be uploaded and executed on the server.', 
0, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),

(uuid_generate_v4(), @RCE_MODULE_ID, 'Command Injection Vulnerabilities', 'command-injection-vulnerabilities', 
'Learn how command injection vulnerabilities work and how to prevent them.', 
'markdown', 
'# Command Injection Vulnerabilities

## What is Command Injection?

Command injection occurs when an application passes unsafe user-supplied data to a system shell. By injecting malicious commands, an attacker can execute arbitrary commands on the host operating system.

## How Command Injection Works

Consider this PHP code:

\`\`\`
<?php
    $ip = $_GET[''ip'']; /* User-controlled input */
    system("ping -c 4 " . $ip); /* Directly used in system command */
?>
\`\`\`

If a user provides the input `8.8.8.8; ls -la`, the system will execute:

\`\`\`
ping -c 4 8.8.8.8; ls -la
\`\`\`

This will first ping Google''s DNS server and then list all files in the current directory.

## Common Injection Characters

- `;` - Command separator (Unix/Linux/Windows)
- `&&` - Command chaining (execution only if previous command succeeds)
- `||` - Command chaining (execution only if previous command fails)
- `|` - Pipe output to another command
- `$()` or backticks - Command substitution', 
1, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),

(uuid_generate_v4(), @RCE_MODULE_ID, 'Securing Applications Against RCE', 'securing-against-rce', 
'Learn best practices for preventing Remote Code Execution vulnerabilities.', 
'markdown', 
'# Securing Applications Against RCE

## General Principles

1. **Input Validation**: Always validate and sanitize user input
2. **Least Privilege**: Run applications with minimal required permissions
3. **Parameterized APIs**: Use safe APIs that separate code from data
4. **Sandboxing**: Run untrusted code in isolated environments

## Preventing Command Injection

### Use Language Features Instead of Shell Commands

\`\`\`
/* Vulnerable - using shell */
import os
os.system("rm -rf " + user_input)  /* Dangerous! */

/* Secure - using language features */
import os
os.remove(user_input)  /* Safer - no shell interpretation */
\`\`\`

### If Shell Commands Are Necessary, Use Safe APIs

\`\`\`
/* Vulnerable */
import os
os.system("ping " + ip_address)  /* Dangerous! */

/* Secure */
import subprocess
subprocess.run(["ping", ip_address], check=True)  /* Safe - no shell interpretation */
\`\`\`

## Preventing Deserialization Vulnerabilities

1. **Never deserialize untrusted data**
2. **Use data format that doesn''t allow code execution** (JSON instead of pickle/YAML)
3. **Implement integrity checks** (digital signatures for serialized data)

\`\`\`
/* Vulnerable */
import pickle
data = pickle.loads(user_input)  /* Dangerous! */

/* Safer */
import json
data = json.loads(user_input)  /* Safer, but still validate! */
\`\`\`

## Regular Security Testing

1. **Code Reviews**: Regularly review code for potential RCE vulnerabilities
2. **Penetration Testing**: Conduct regular penetration tests
3. **Static Analysis**: Use automated tools to detect potential vulnerabilities
4. **Keep Dependencies Updated**: Regularly update all dependencies to patch known vulnerabilities', 
2, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP);

-- Commit all inserts
COMMIT;

-- Add testing SQL for verifying lessons were added correctly

-- Test CSRF module lessons
SELECT COUNT(*) AS csrf_lesson_count FROM lessons WHERE module_id = @CSRF_MODULE_ID;

-- Test Broken Access Control module lessons
SELECT COUNT(*) AS access_control_lesson_count FROM lessons WHERE module_id = @ACCESS_CONTROL_MODULE_ID;

-- Test Buffer Overflow module lessons
SELECT COUNT(*) AS buffer_overflow_lesson_count FROM lessons WHERE module_id = @BUFFER_OVERFLOW_MODULE_ID;

-- Test Remote Code Execution module lessons
SELECT COUNT(*) AS rce_lesson_count FROM lessons WHERE module_id = @RCE_MODULE_ID;

-- Display all lessons for verification
SELECT m.name AS module_name, l.title AS lesson_title, l.slug, l.order_index
FROM modules m
JOIN lessons l ON m.id = l.module_id
ORDER BY m.order_index, l.order_index;

-- Clean up the UUID function if not needed elsewhere
-- Uncomment the line below if you want to drop the function after use
-- DROP FUNCTION IF EXISTS uuid_generate_v4;
