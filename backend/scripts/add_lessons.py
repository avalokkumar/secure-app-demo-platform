"""
Script to add lessons to intermediate and advanced modules.

This script uses the database models directly to add lessons to modules.
Run this script from the backend directory with: python scripts/add_lessons.py
"""
import sys
import os
import uuid
from datetime import datetime

# Add the parent directory to the Python path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from models.db import db
from models.module import Module
from models.lesson import Lesson
from app import create_app

# Create Flask app with database connection
app = create_app()

# Module IDs (from test results)
CSRF_MODULE_ID = '70962424-4ed9-11f0-8cc9-26298fe937f6'
ACCESS_CONTROL_MODULE_ID = '70962c4e-4ed9-11f0-8cc9-26298fe937f6'
BUFFER_OVERFLOW_MODULE_ID = '70962dd4-4ed9-11f0-8cc9-26298fe937f6'
RCE_MODULE_ID = '70962e2e-4ed9-11f0-8cc9-26298fe937f6'

# CSRF module lessons (keep these short for better performance)
csrf_lessons = [
    {
        "title": "Understanding CSRF Attacks",
        "slug": "understanding-csrf-attacks",
        "description": "Learn the fundamentals of Cross-Site Request Forgery attacks and how they exploit user trust.",
        "content_type": "markdown",
        "content": """# Understanding CSRF Attacks

## Introduction to CSRF

Cross-Site Request Forgery (CSRF) is a type of web security vulnerability that allows an attacker to trick authenticated users into performing unwanted actions on a web application. Unlike XSS, which exploits the trust a user has for a site, CSRF exploits the trust that a website has in a user's browser.

## How CSRF Works

CSRF attacks work by taking advantage of websites that rely solely on session cookies for authentication. Here's a typical scenario:

1. You log into your bank account at bank.com and receive an authentication cookie.
2. Without logging out, you visit a malicious website.
3. The malicious site contains code that automatically sends a request to bank.com to transfer money.
4. Since your browser still has the authentication cookie for bank.com, the request is sent with your credentials.
5. The bank processes the transaction because it appears to be coming from you.

## Common CSRF Attack Vectors

- **GET Requests**: Simple image tags or iframes that execute when loaded.
- **POST Requests**: Hidden forms that automatically submit using JavaScript.
- **Clickjacking**: Tricking users into clicking on disguised buttons that trigger actions.

## CSRF Attack Example

Here's a simple example of a CSRF attack using HTML:

```html
<!-- This image tag silently makes a GET request that changes your email -->
<img src="https://vulnerable-bank.com/account/change-email?new=hacker@evil.com" 
     width="0" height="0" border="0">
```

Or using a hidden form that automatically submits:

```html
<body onload="document.csrf_form.submit()">
<form action="https://vulnerable-bank.com/transfer" method="POST" name="csrf_form">
  <input type="hidden" name="recipient" value="hacker">
  <input type="hidden" name="amount" value="10000">
</form>
</body>
```

In the next lesson, we'll explore CSRF protection mechanisms and how to prevent these attacks.""",
        "order_index": 0,
        "is_active": True
    },
    {
        "title": "CSRF Protection Mechanisms",
        "slug": "csrf-protection-mechanisms",
        "description": "Learn about various techniques to protect web applications from CSRF attacks.",
        "content_type": "markdown",
        "content": """# CSRF Protection Mechanisms

## Anti-CSRF Tokens

The most common and effective protection against CSRF attacks is the use of anti-CSRF tokens (also called synchronizer tokens or challenge tokens). These are unique, unpredictable values that are generated by the server and sent to the client.

### How Anti-CSRF Tokens Work

1. The server generates a unique token and includes it in the form.
2. When the form is submitted, the token is sent back to the server.
3. The server verifies that the token is valid before processing the request.
4. Attackers cannot guess or obtain this token, so they cannot forge valid requests.

Example implementation in various frameworks:

```python
# Flask implementation
from flask import Flask, request, session
from flask_wtf.csrf import CSRFProtect

app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key'
csrf = CSRFProtect(app)

# The CSRF token is automatically added to forms
```

```javascript
// React implementation with axios
import axios from 'axios';

// Get CSRF token from a meta tag
const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');

// Include token in all requests
axios.defaults.headers.common['X-CSRF-Token'] = csrfToken;
```

## Same-Site Cookies

Modern browsers support the SameSite attribute for cookies, which provides protection against CSRF attacks:

```
Set-Cookie: sessionid=abc123; SameSite=Strict
```

SameSite settings:
- **Strict**: The cookie is only sent to the same site as the one that originated it.
- **Lax**: The cookie is sent when the user navigates to the site from another site.
- **None**: The cookie is sent with all requests, but requires the Secure attribute.

## Double Submit Cookie Pattern

Another technique is the double submit cookie pattern:

1. Server sets a cookie with a random value.
2. Server also includes the same value as a hidden field in forms.
3. When a form is submitted, server verifies both values match.

## Custom Request Headers

For AJAX requests, custom headers can be used as browsers prevent cross-domain custom headers:

```javascript
fetch('/api/data', {
  method: 'POST',
  headers: {
    'X-Requested-With': 'XMLHttpRequest', // Custom header
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(data)
})
```

In the next lesson, we'll implement CSRF protection in a sample application.""",
        "order_index": 1,
        "is_active": True
    },
    {
        "title": "Implementing CSRF Protection",
        "slug": "implementing-csrf-protection",
        "description": "Learn how to implement practical CSRF protection in web applications.",
        "content_type": "markdown",
        "content": """# Implementing CSRF Protection

In this lesson, we'll implement CSRF protection in a sample web application. We'll demonstrate how to properly protect against CSRF attacks in different frameworks and scenarios.

## Implementing Anti-CSRF Tokens

### Server-Side Implementation (Node.js/Express)

```javascript
const express = require('express');
const session = require('express-session');
const csrf = require('csurf');
const bodyParser = require('body-parser');

const app = express();

// Set up session middleware
app.use(session({
  secret: 'your-secret-key',
  resave: false,
  saveUninitialized: true,
  cookie: {
    secure: process.env.NODE_ENV === 'production', // Use secure cookies in production
    httpOnly: true // Cookie not accessible via JavaScript
  }
}));

// Parse form data
app.use(bodyParser.urlencoded({ extended: false }));

// Set up CSRF protection
const csrfProtection = csrf({ cookie: false }); // Using session instead of cookie

// Apply CSRF protection to all POST routes
app.post('/api/*', csrfProtection, (req, res, next) => {
  next();
});

// Generate and provide CSRF token for forms
app.get('/form', csrfProtection, (req, res) => {
  // Pass the token to your template
  res.render('form', { csrfToken: req.csrfToken() });
});

// Handle form submission with CSRF validation
app.post('/submit-form', csrfProtection, (req, res) => {
  // Process form - CSRF is automatically validated
  res.send('Form submitted successfully');
});

// Error handler for CSRF token validation failures
app.use((err, req, res, next) => {
  if (err.code === 'EBADCSRFTOKEN') {
    // CSRF token validation failed
    return res.status(403).send('CSRF token validation failed');
  }
  
  // Handle other errors
  next(err);
});
```

### Client-Side Implementation (HTML Form)

```html
<form action="/submit-form" method="POST">
  <!-- Hidden field for CSRF token -->
  <input type="hidden" name="_csrf" value="{{csrfToken}}">
  
  <label for="username">Username:</label>
  <input type="text" id="username" name="username">
  
  <label for="email">Email:</label>
  <input type="email" id="email" name="email">
  
  <button type="submit">Submit</button>
</form>
```

### AJAX Implementation (Fetch API)

```javascript
// Get the CSRF token from a meta tag
const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');

// Function to make API calls with CSRF protection
async function secureApiCall(url, data) {
  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': csrfToken // Include CSRF token in header
      },
      body: JSON.stringify(data)
    });
    
    return await response.json();
  } catch (error) {
    console.error('API call failed:', error);
    throw error;
  }
}

// Example usage
document.getElementById('update-form').addEventListener('submit', async (event) => {
  event.preventDefault();
  
  const formData = {
    username: document.getElementById('username').value,
    email: document.getElementById('email').value
  };
  
  try {
    const result = await secureApiCall('/api/update-profile', formData);
    console.log('Profile updated:', result);
  } catch (error) {
    // Handle error
  }
});
```

## Implementing SameSite Cookies

### Setting SameSite Attributes (Node.js/Express)

```javascript
const express = require('express');
const session = require('express-session');

const app = express();

app.use(session({
  secret: 'your-secret-key',
  resave: false,
  saveUninitialized: true,
  cookie: {
    secure: process.env.NODE_ENV === 'production', // Use secure cookies in production
    httpOnly: true, // Cookie not accessible via JavaScript
    sameSite: 'strict' // Only sent in same-site requests
  }
}));
```

In the next lesson, we'll explore advanced CSRF scenarios and learn how to test for CSRF vulnerabilities.""",
        "order_index": 2,
        "is_active": True
    },
    {
        "title": "CSRF Testing and Case Studies",
        "slug": "csrf-testing-case-studies",
        "description": "Learn how to test for CSRF vulnerabilities and analyze real-world CSRF attack examples.",
        "content_type": "markdown",
        "content": """# CSRF Testing and Case Studies

## Testing for CSRF Vulnerabilities

### Manual Testing Approach

1. **Identify Sensitive Actions**: Find actions that change state (e.g., transfers, password changes).

2. **Check for CSRF Protections**: Examine requests for:
   - CSRF tokens in forms or headers
   - SameSite cookie attributes
   - Origin/Referer header validation

3. **Create a Proof of Concept**: Build an HTML file that reproduces the request:

```html
<!-- CSRF PoC for a vulnerable transfer form -->
<html>
  <body onload="document.getElementById('csrf-form').submit()">
    <form id="csrf-form" action="https://vulnerable-bank.com/transfer" method="POST">
      <input type="hidden" name="recipient" value="attacker" />
      <input type="hidden" name="amount" value="1000" />
    </form>
  </body>
</html>
```

4. **Verify the Attack**: Load the PoC in a browser with an active session to the vulnerable application.

### Automated Testing Tools

- **OWASP ZAP**: Includes CSRF scanners and can test for missing protections.
- **Burp Suite**: The CSRF PoC generator creates attack templates automatically.

```
# Using OWASP ZAP CLI to scan for CSRF
./zap.sh -cmd -quickurl https://example.com -quickprogress -quickout csrf_report.html
```

## Real-World CSRF Case Studies

### Case Study 1: Twitter CSRF Vulnerability (2010)

In 2010, Twitter had a CSRF vulnerability that allowed attackers to force users to follow arbitrary accounts:

**Vulnerability**: Twitter's follow action didn't require a CSRF token.

**Attack Vector**: A simple link or hidden iframe could trigger the follow action.

**Impact**: Widespread accounts followed malicious profiles without consent.

**Resolution**: Twitter implemented proper CSRF protections and temporarily reset all followers/following relationships.

### Case Study 2: YouTube Creator Studio (2019)

A vulnerability in YouTube Studio allowed attackers to delete videos via CSRF:

**Vulnerability**: The video deletion endpoint didn't properly validate CSRF tokens.

**Attack Vector**: A malicious website could trigger deletion requests when visited by authenticated YouTube creators.

**Impact**: Potential loss of content for YouTube creators.

**Resolution**: Google fixed the vulnerability and awarded a bug bounty to the researcher.

## Lessons Learned from Real-World CSRF Attacks

1. **Don't Rely on Obscurity**: Using complex or non-standard request formats doesn't provide protection.

2. **Test All Critical Functions**: Every state-changing operation needs CSRF protection.

3. **Implement Defense in Depth**: Combine tokens with SameSite cookies and other protections.

4. **Monitor for Suspicious Activity**: Track unusual patterns of state-changing operations.

## CSRF Protection Checklist

- [ ] Use anti-CSRF tokens for all state-changing operations
- [ ] Set appropriate SameSite cookie attributes
- [ ] Implement additional protections for high-value operations
- [ ] Validate the Origin/Referer header where appropriate
- [ ] Require re-authentication for sensitive actions
- [ ] Regularly test for CSRF vulnerabilities

In the next lesson, we'll provide a hands-on exercise to practice identifying and fixing CSRF vulnerabilities.""",
        "order_index": 3,
        "is_active": True
    },
    {
        "title": "CSRF Practical Exercise",
        "slug": "csrf-practical-exercise",
        "description": "Apply your knowledge with a hands-on exercise to identify and fix CSRF vulnerabilities.",
        "content_type": "markdown",
        "content": """# CSRF Practical Exercise

In this practical exercise, you'll identify and fix CSRF vulnerabilities in a sample application. This hands-on approach will help reinforce the concepts you've learned in the previous lessons.

## Exercise: Identify and Fix CSRF Vulnerabilities

### Scenario

You are a security engineer tasked with reviewing a user profile management system. Users can update their profile information, change their email address, and modify account settings. Your goal is to identify potential CSRF vulnerabilities and implement appropriate protections.

### Part 1: Identify Vulnerabilities

Below is a simplified version of the application code. Review it and identify potential CSRF vulnerabilities:

**Server-side code (Express.js):**

```javascript
const express = require('express');
const session = require('express-session');
const bodyParser = require('body-parser');

const app = express();

// Setup session
app.use(session({
  secret: 'session-secret',
  resave: false,
  saveUninitialized: true,
  cookie: { secure: false, httpOnly: true }
}));

// Parse request bodies
app.use(bodyParser.urlencoded({ extended: false }));
app.use(bodyParser.json());

// User authentication middleware
function requireLogin(req, res, next) {
  if (req.session.userId) {
    next();
  } else {
    res.redirect('/login');
  }
}

// API endpoints
app.post('/api/update-profile', requireLogin, (req, res) => {
  // Update user profile in database
  const { name, bio } = req.body;
  updateUserProfile(req.session.userId, name, bio);
  res.json({ success: true });
});

app.post('/api/change-email', requireLogin, (req, res) => {
  // Change user email in database
  const { email } = req.body;
  updateUserEmail(req.session.userId, email);
  res.json({ success: true });
});

app.post('/api/delete-account', requireLogin, (req, res) => {
  // Delete user account
  deleteUserAccount(req.session.userId);
  req.session.destroy();
  res.redirect('/goodbye');
});
```

**Client-side code (HTML/JavaScript):**

```html
<!-- Profile update form -->
<form id="profile-form" action="/api/update-profile" method="POST">
  <label for="name">Name:</label>
  <input type="text" id="name" name="name" value="Current Name">
  
  <label for="bio">Bio:</label>
  <textarea id="bio" name="bio">Current bio text...</textarea>
  
  <button type="submit">Update Profile</button>
</form>

<!-- Email change form -->
<form id="email-form" action="/api/change-email" method="POST">
  <label for="email">New Email:</label>
  <input type="email" id="email" name="email">
  
  <button type="submit">Change Email</button>
</form>

<!-- Account deletion -->
<form id="delete-form" action="/api/delete-account" method="POST">
  <p>This action cannot be undone.</p>
  <button type="submit">Delete My Account</button>
</form>
```

### Part 2: Implement CSRF Protection

Now that you've identified the vulnerabilities, implement appropriate CSRF protections for the application:

1. Add CSRF token generation and validation
2. Update the server-side code to handle CSRF protection
3. Modify the client-side forms to include CSRF tokens
4. Implement any additional protections you think are necessary

### Part 3: Test Your Solution

Create a CSRF attack demonstration that would work against the original vulnerable code, then show how your implemented protections prevent the attack.""",
        "order_index": 4,
        "is_active": True
    }
]

def add_lessons_to_module(module_id, lessons):
    """Add lessons to a module."""
    # Check if module exists
    module = Module.query.get(module_id)
    if not module:
        print(f"Module with ID {module_id} not found.")
        return False
    
    print(f"Adding lessons to module: {module.name} (ID: {module_id})")
    
    # Add each lesson
    for lesson_data in lessons:
        # Check if lesson with this slug already exists
        existing = Lesson.query.filter_by(module_id=module_id, slug=lesson_data["slug"]).first()
        if existing:
            print(f"Lesson with slug '{lesson_data['slug']}' already exists in this module. Skipping.")
            continue
        
        # Create new lesson
        lesson = Lesson(
            id=str(uuid.uuid4()),
            module_id=module_id,
            title=lesson_data["title"],
            slug=lesson_data["slug"],
            description=lesson_data["description"],
            content_type=lesson_data["content_type"],
            content=lesson_data["content"],
            order_index=lesson_data["order_index"],
            is_active=lesson_data["is_active"],
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )
        
        db.session.add(lesson)
        print(f"Added lesson: {lesson.title}")
    
    # Commit changes
    db.session.commit()
    print(f"Successfully added {len(lessons)} lessons to module {module.name}")
    return True

# Create test for lessons in backend/tests/test_lessons.py
def create_test_file():
    """Create a test file for lesson functionality."""
    test_content = '''import pytest
from models.module import Module
from models.lesson import Lesson

def test_csrf_lessons_exist(client):
    # Test that CSRF module has at least 4 lessons.
    module = Module.query.filter_by(slug='csrf').first()
    assert module is not None, "CSRF module not found"
    
    lessons = Lesson.query.filter_by(module_id=module.id).all()
    assert len(lessons) >= 4, f"Expected at least 4 lessons in CSRF module, found {len(lessons)}"

def test_access_control_lessons_exist(client):
    # Test that Broken Access Control module has lessons.
    module = Module.query.filter_by(slug='broken-access-control').first()
    assert module is not None, "Broken Access Control module not found"
    
    lessons = Lesson.query.filter_by(module_id=module.id).all()
    assert len(lessons) >= 2, f"Expected at least 2 lessons in Broken Access Control module, found {len(lessons)}"

def test_buffer_overflow_lessons_exist(client):
    # Test that Buffer Overflow module has lessons.
    module = Module.query.filter_by(slug='buffer-overflow').first()
    assert module is not None, "Buffer Overflow module not found"
    
    lessons = Lesson.query.filter_by(module_id=module.id).all()
    assert len(lessons) >= 2, f"Expected at least 2 lessons in Buffer Overflow module, found {len(lessons)}"

def test_rce_lessons_exist(client):
    # Test that Remote Code Execution module has lessons.
    module = Module.query.filter_by(slug='rce').first()
    assert module is not None, "Remote Code Execution module not found"
    
    lessons = Lesson.query.filter_by(module_id=module.id).all()
    assert len(lessons) >= 2, f"Expected at least 2 lessons in Remote Code Execution module, found {len(lessons)}"
'''
    
    # Create the test file
    test_file_path = os.path.join(os.path.dirname(__file__), '..', 'tests', 'test_lessons.py')
    with open(test_file_path, 'w') as f:
        f.write(test_content)
    
    print(f"Created test file at {test_file_path}")

# Broken Access Control module lessons
access_control_lessons = [
    {
        "title": "Understanding Access Control",
        "slug": "understanding-access-control",
        "description": "Learn the fundamentals of access control and its importance in web security.",
        "content_type": "markdown",
        "content": """# Understanding Access Control

## Introduction to Access Control

Access control is a security technique that regulates who or what can view or use resources in a computing environment. It is a fundamental security concept that minimizes risk to the business or organization.

## Types of Access Control

### Discretionary Access Control (DAC)
In DAC, the owner of a resource determines who can access it. For example, file permissions in operating systems.

### Mandatory Access Control (MAC)
MAC enforces access control based on regulations mandated by a central authority. Users cannot override these rules.

### Role-Based Access Control (RBAC)
RBAC assigns permissions to specific roles, and users are assigned to those roles. Most common in enterprise applications.

### Attribute-Based Access Control (ABAC)
ABAC uses attributes (user attributes, resource attributes, environment attributes) to determine access rights.""",
        "order_index": 0,
        "is_active": True
    },
    {
        "title": "Broken Access Control Vulnerabilities",
        "slug": "broken-access-control-vulnerabilities",
        "description": "Learn about common access control vulnerabilities and how they can be exploited.",
        "content_type": "markdown",
        "content": """# Broken Access Control Vulnerabilities

## Common Vulnerabilities

### 1. Insecure Direct Object References (IDOR)
IDOR occurs when an application provides direct access to objects based on user-supplied input.

### 2. Missing Function Level Access Control
When authorization checks are performed at the UI level but not at the API or controller level.

### 3. CORS Misconfiguration
Improper Cross-Origin Resource Sharing (CORS) configuration allowing unauthorized domains to access sensitive data.

### 4. Elevation of Privilege
When a user can change their permission level or access resources beyond their authorization.""",
        "order_index": 1,
        "is_active": True
    }
]

# Buffer Overflow module lessons
buffer_overflow_lessons = [
    {
        "title": "Buffer Overflow Fundamentals",
        "slug": "buffer-overflow-fundamentals",
        "description": "Learn the basics of buffer overflow vulnerabilities and how they work.",
        "content_type": "markdown",
        "content": """# Buffer Overflow Fundamentals

## What is a Buffer Overflow?

A buffer overflow occurs when a program writes data beyond the boundaries of pre-allocated fixed-length buffers. This can lead to behavior including memory access errors, incorrect results, program crashes, or a breach of system security.

## How Buffer Overflows Work

In low-level languages like C and C++, developers must manually manage memory by allocating and freeing it. When more data is written to a buffer than it can hold, the excess data can overflow into adjacent memory locations.

### Example in C

```c
#include <string.h>

void vulnerable_function(char *input) {
    char buffer[10]; // Only 10 bytes allocated
    strcpy(buffer, input); // No bounds checking
}

int main(int argc, char *argv[]) {
    vulnerable_function(argv[1]); // User-controlled input
    return 0;
}
```

If a user inputs more than 10 characters, the buffer will overflow, potentially overwriting adjacent memory locations.""",
        "order_index": 0,
        "is_active": True
    },
    {
        "title": "Stack-Based Buffer Overflows",
        "slug": "stack-based-buffer-overflows",
        "description": "Learn about stack-based buffer overflows and their exploitation techniques.",
        "content_type": "markdown",
        "content": """# Stack-Based Buffer Overflows

## The Stack and Its Structure

The stack is a region of memory that stores local variables, function parameters, and return addresses. It operates on a Last-In-First-Out (LIFO) principle.

## Stack Buffer Overflow

In a stack buffer overflow, the attacker overwrites local variables and can potentially modify the function's return address, redirecting the program execution to malicious code.

## Components of a Stack Frame

1. **Local Variables**: Where the vulnerable buffer is typically located
2. **Saved Frame Pointer (SFP)**: Points to the previous stack frame
3. **Return Address**: Where program execution should return after the function completes
4. **Function Parameters**: Arguments passed to the function

## Basic Exploitation Technique

1. Identify a buffer overflow vulnerability
2. Determine the offset to the return address
3. Overwrite the return address with the address of malicious code
4. Include shellcode in the payload""",
        "order_index": 1,
        "is_active": True
    }
]

# Remote Code Execution module lessons
rce_lessons = [
    {
        "title": "Introduction to Remote Code Execution",
        "slug": "introduction-to-rce",
        "description": "Learn the basics of Remote Code Execution (RCE) vulnerabilities and their impact.",
        "content_type": "markdown",
        "content": """# Introduction to Remote Code Execution

## What is Remote Code Execution (RCE)?

Remote Code Execution is a critical vulnerability that allows an attacker to execute arbitrary code on a target system remotely. RCE vulnerabilities give attackers the ability to compromise a system completely, potentially leading to data theft, system damage, or use of the compromised system to attack other targets.

## Common RCE Vulnerability Types

### 1. Command Injection
When user input is improperly sanitized and used directly in system commands.

### 2. Deserialization Vulnerabilities
When untrusted data is deserialized, potentially leading to code execution if the serialized data contains malicious code.

### 3. Server-Side Template Injection
When user input is incorporated into templates that are then executed on the server.

### 4. File Upload Vulnerabilities
When file upload functions allow executable code to be uploaded and executed on the server.""",
        "order_index": 0,
        "is_active": True
    },
    {
        "title": "Command Injection Vulnerabilities",
        "slug": "command-injection-vulnerabilities",
        "description": "Learn how command injection vulnerabilities work and how to prevent them.",
        "content_type": "markdown",
        "content": """# Command Injection Vulnerabilities

## What is Command Injection?

Command injection occurs when an application passes unsafe user-supplied data to a system shell. By injecting malicious commands, an attacker can execute arbitrary commands on the host operating system.

## How Command Injection Works

Consider this PHP code:

```php
<?php
    $ip = $_GET['ip']; // User-controlled input
    system("ping -c 4 " . $ip); // Directly used in system command
?>
```

If a user provides the input `8.8.8.8; ls -la`, the system will execute:

```
ping -c 4 8.8.8.8; ls -la
```

This will first ping Google's DNS server and then list all files in the current directory.

## Common Injection Characters

- `;` - Command separator (Unix/Linux/Windows)
- `&&` - Command chaining (execution only if previous command succeeds)
- `||` - Command chaining (execution only if previous command fails)
- `|` - Pipe output to another command
- `$()` or backticks - Command substitution""",
        "order_index": 1,
        "is_active": True
    }
]

if __name__ == "__main__":
    with app.app_context():
        # Add CSRF module lessons
        add_lessons_to_module(CSRF_MODULE_ID, csrf_lessons)
        print("CSRF lessons added successfully!")
        
        # Add Broken Access Control module lessons
        add_lessons_to_module(ACCESS_CONTROL_MODULE_ID, access_control_lessons)
        print("Broken Access Control lessons added successfully!")
        
        # Add Buffer Overflow module lessons
        add_lessons_to_module(BUFFER_OVERFLOW_MODULE_ID, buffer_overflow_lessons)
        print("Buffer Overflow lessons added successfully!")
        
        # Add Remote Code Execution module lessons
        add_lessons_to_module(RCE_MODULE_ID, rce_lessons)
        print("Remote Code Execution lessons added successfully!")
        
        # Create test file
        create_test_file()
        print("Test file created successfully!")
        
        print("\nAll module lessons have been successfully added to the database!")
